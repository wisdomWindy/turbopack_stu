# turbopack

## 什么是turbopack

turbopack 是一个增量捆绑器和构建系统，针对JavaScript和Typescript进行了优化，由Rust编写。

不使用原生ESModule，而是把源代码捆绑到开发服务器，提高开发服务器的启动速度

### 概念

#### 增量计算

#### 懒打包

#### 缓存任务

turbopack将执行的每一条脚本称之为任务，它会对每一个任务的结果进行缓存

当进行build任务时，先到缓存中读取被构建的文件的缓存，如果找不到就进行构建，构建完毕把结果写入缓存

#### 缓存入口

当指定入口文件发生变化时重新执行任务

```json
// turbo.json
{
  "pipeline":{
    "build":{
      "input":["src/*.js"]
    }
  }
}
```

#### 缓存输出

覆盖默认的缓存输出行为

```json
{
  "pipline":{
    "build":{
      "output":["dist/"]
    }
  }
}
```

#### 禁用缓存

```json
{
  "pipeLine":{
    "dev":{
      "cache":false
    }
  }
}
```

#### 基于环境变量的缓存变更

```json
{
  "pipeline":{
    "test":{
      "env":["VUE_APP"]
    }
  }
}
```

#### 日志

turbopack引擎会缓存控制台的输出日志，当再次执行相同任务时，会从缓存读取输出

#### hashing

1. 构建一个代码库当前全局状态的hash
2. 添加给定工作区任务的更过因素
3. 一旦turbo在执行中遇到给定工作区的任务，它会检查缓存（本地和远程）是否有匹配的哈希。如果匹配，它会跳过执行该任务，将缓存的输出移动或下载到位，并立即重放之前记录的日志。如果缓存中没有任何东西（本地或远程）与计算的哈希匹配，turbo将在本地执行任务，然后使用哈希作为索引缓存指定的输出
4. 给定任务的哈希值在执行时作为环境变量TURBO_HASH注入。此值可用于标记输出或标记Dockerfile等

**在turbo v0.6.10中，turbo在使用npm或pnpm时的散列算法与上述略有不同。当使用这些包管理器中的任何一个时，turbo将在其每个工作区任务的散列算法中包含锁文件的散列内容。它不会像当前的纱线实现那样解析/计算出所有依赖项的解析集**

### 原理

要想使性能更快需要
 - 做更少的工作
 - 并行工作

turbopack在这两方面进行优化，turbopack创建一个共享的构建引擎，构建引擎允许函数并行调用，构建引擎缓存函数调用后的结果。

Turbopack的开发模式根据收到的请求构建应用程序导入和导出的最小图，并且仅捆绑必要的最小代码。
这种策略使Turbopack在首次启动开发服务器时速度极快。我们只计算渲染页面所需的代码，然后将其以单个块的形式发送到浏览器。在大规模上，这最终比原生ESM快得多

### 应用场景

turbopack适用于大型应用

### 优势

- 比Vite快10倍，比webpack快700倍：
  - 高度优化的机器代码
  - 低级增量计算引擎，允许缓存到单个函数的级别

- 增量计算：最大化速度，最小化完成的工作
- 优化开发服务器的启动时间：构建一个惰性资产图仅计算请求的资源


Vite的劣势：
- 扩展问题：大量的级联请求影响启动速度


### 劣势



